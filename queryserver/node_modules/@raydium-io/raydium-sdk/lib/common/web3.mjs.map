{"version":3,"sources":["../../src/common/web3.ts","../../src/common/lodash.ts","../../src/common/logger.ts","../../src/version.ts"],"sourcesContent":["// import BN from 'bn.js';\n\n// import { Spl, SPL_ACCOUNT_LAYOUT } from '../spl';\n// import { TOKEN_PROGRAM_ID } from './id';\n\nimport {\n  AccountInfo, Commitment, Connection, Keypair, PublicKey, Signer, SimulatedTransactionResponse, Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { chunkArray } from \"./lodash\";\nimport { Logger } from \"./logger\";\n\nconst logger = Logger.from(\"common/web3\");\n\ninterface MultipleAccountsJsonRpcResponse {\n  jsonrpc: string;\n  id: string;\n  error?: {\n    code: number;\n    message: string;\n  };\n  result: {\n    context: { slot: number };\n    value: { data: Array<string>; executable: boolean; lamports: number; owner: string; rentEpoch: number }[];\n  };\n}\n\nexport interface GetMultipleAccountsInfoConfig {\n  batchRequest?: boolean;\n  commitment?: Commitment;\n}\n\n// export async function batchGetMultipleAccountsInfo() {}\n\nexport async function getMultipleAccountsInfo(\n  connection: Connection,\n  publicKeys: PublicKey[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<(AccountInfo<Buffer> | null)[]> {\n  const { batchRequest, commitment } = {\n    // default\n    ...{\n      batchRequest: false,\n    },\n    // custom\n    ...config,\n  };\n\n  const chunkedKeys = chunkArray(publicKeys, 100);\n  let results: (AccountInfo<Buffer> | null)[][] = new Array(chunkedKeys.length).fill([]);\n\n  if (batchRequest) {\n    const batch = chunkedKeys.map((keys) => {\n      const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, \"base64\");\n      return {\n        methodName: \"getMultipleAccounts\",\n        args,\n      };\n    });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const unsafeResponse: MultipleAccountsJsonRpcResponse[] = await connection._rpcBatchRequest(batch);\n    results = unsafeResponse.map((unsafeRes: MultipleAccountsJsonRpcResponse) => {\n      if (unsafeRes.error) {\n        return logger.throwError(\"failed to get info for multiple accounts\", Logger.errors.RPC_ERROR, {\n          message: unsafeRes.error.message,\n        });\n      }\n\n      return unsafeRes.result.value.map((accountInfo) => {\n        if (accountInfo) {\n          const { data, executable, lamports, owner, rentEpoch } = accountInfo;\n\n          if (data.length !== 2 && data[1] !== \"base64\") {\n            return logger.throwError(\"info must be base64 encoded\", Logger.errors.RPC_ERROR);\n          }\n\n          return {\n            data: Buffer.from(data[0], \"base64\"),\n            executable,\n            lamports,\n            owner: new PublicKey(owner),\n            rentEpoch,\n          };\n        } else {\n          return null;\n        }\n      });\n    });\n  } else {\n    try {\n      results = (await Promise.all(\n        chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment)),\n      )) as (AccountInfo<Buffer> | null)[][];\n    } catch (error) {\n      if (error instanceof Error) {\n        return logger.throwError(\"failed to get info for multiple accounts\", Logger.errors.RPC_ERROR, {\n          message: error.message,\n        });\n      }\n    }\n  }\n\n  return results.flat();\n}\n\nexport async function getMultipleAccountsInfoWithCustomFlags<T extends { pubkey: PublicKey }>(\n  connection: Connection,\n  publicKeysWithCustomFlag: T[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<({ accountInfo: AccountInfo<Buffer> | null } & T)[]> {\n  const multipleAccountsInfo = await getMultipleAccountsInfo(\n    connection,\n    publicKeysWithCustomFlag.map((o) => o.pubkey),\n    config,\n  );\n\n  return publicKeysWithCustomFlag.map((o, idx) => ({ ...o, accountInfo: multipleAccountsInfo[idx] }));\n}\n\nexport interface GetTokenAccountsByOwnerConfig {\n  commitment?: Commitment;\n}\n\n// export async function getTokenAccountsByOwner(\n//   connection: Connection,\n//   owner: PublicKey,\n//   config?: GetTokenAccountsByOwnerConfig\n// ) {\n//   const defaultConfig = {};\n//   const customConfig = { ...defaultConfig, ...config };\n\n//   const solReq = connection.getAccountInfo(owner, customConfig.commitment);\n//   const tokenReq = connection.getTokenAccountsByOwner(\n//     owner,\n//     {\n//       programId: TOKEN_PROGRAM_ID\n//     },\n//     customConfig.commitment\n//   );\n\n//   const [solResp, tokenResp] = await Promise.all([solReq, tokenReq]);\n\n//   const accounts: {\n//     publicKey?: PublicKey;\n//     mint?: PublicKey;\n//     isAssociated?: boolean;\n//     amount: BN;\n//     isNative: boolean;\n//   }[] = [];\n\n//   for (const { pubkey, account } of tokenResp.value) {\n//     // double check layout length\n//     if (account.data.length !== SPL_ACCOUNT_LAYOUT.span) {\n//       return logger.throwArgumentError('invalid token account layout length', 'publicKey', pubkey);\n//     }\n\n//     const { mint, amount } = SPL_ACCOUNT_LAYOUT.decode(account.data);\n//     const associatedTokenAddress = await Spl.getAssociatedTokenAddress({ mint, owner });\n\n//     accounts.push({\n//       publicKey: pubkey,\n//       mint,\n//       isAssociated: associatedTokenAddress.equals(pubkey),\n//       amount,\n//       isNative: false\n//     });\n//   }\n\n//   if (solResp) {\n//     accounts.push({\n//       amount: new BN(solResp.lamports),\n//       isNative: true\n//     });\n//   }\n\n//   return accounts;\n// }\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]) {\n  if (instructions.length < 1) {\n    return logger.throwArgumentError(\"no instructions provided\", \"instructions\", instructions);\n  }\n  if (signers.length < 1) {\n    return logger.throwArgumentError(\"no signers provided\", \"signers\", signers);\n  }\n\n  const transaction = new Transaction({\n    recentBlockhash: \"11111111111111111111111111111111\",\n    feePayer: signers[0],\n  });\n\n  transaction.add(...instructions);\n\n  try {\n    transaction.serialize({ verifySignatures: false });\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n  batchRequest = true\n) {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer\n\n  for (const instruction of instructions) {\n    if (!forecastTransactionSize([...transaction.instructions, instruction], [feePayer])) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer\n    }\n    transaction.add(instruction);\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: SimulatedTransactionResponse[] = [];\n\n  try {\n    results = await simulateTransaction(connection, transactions, batchRequest)\n    if (results.find(i => i.err !== null)) throw Error('rpc simulateTransaction error')\n  } catch (error) {\n    if (error instanceof Error) {\n      return logger.throwError(\"failed to simulate for instructions\", Logger.errors.RPC_ERROR, {\n        message: error.message,\n      });\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    logger.debug(\"simulate result:\", result);\n\n    if (result.logs) {\n      const filteredLog = result.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(\"filteredLog:\", logs);\n\n      logger.assertArgument(filteredLog.length !== 0, \"simulate log not match keyword\", \"keyword\", keyword);\n\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string) {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.throwArgumentError(\"simulate log fail to match json\", \"keyword\", keyword);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string) {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.throwArgumentError(\"simulate log fail to match key\", \"key\", key);\n  }\n\n  return results[1];\n}\n\nexport async function simulateTransaction(connection: Connection, transactions: Transaction[], batchRequest?: boolean) {\n  let results: any[] = []\n  if (batchRequest) {\n    const getLatestBlockhash = await connection.getLatestBlockhash()\n\n    const encodedTransactions: string[] = []\n    for (const transaction of transactions) {\n      transaction.recentBlockhash = getLatestBlockhash.blockhash\n      transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const message = transaction._compile();\n      const signData = message.serialize();\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const wireTransaction = transaction._serialize(signData);\n      const encodedTransaction = wireTransaction.toString('base64');\n\n      encodedTransactions.push(encodedTransaction)\n    }\n\n    const batch = encodedTransactions.map((keys) => {\n      const args = connection._buildArgs([keys], undefined, \"base64\");\n      return {\n        methodName: \"simulateTransaction\",\n        args,\n      };\n    });\n\n    const reqData: { methodName: string; args: any[]; }[][] = []\n    const itemReqIndex = 20\n    for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {\n      reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex))\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    results = await (await Promise.all(reqData.map(async (i) => (await connection._rpcBatchRequest(i)).map(ii => ii.result.value)))).flat()\n  } else {\n    try {\n      results = (await Promise.all(\n        transactions.map(async (transaction) =>\n          await (await connection.simulateTransaction(transaction)).value\n        )));\n    } catch (error) {\n      if (error instanceof Error) {\n        return logger.throwError(\"failed to get info for multiple accounts\", Logger.errors.RPC_ERROR, {\n          message: error.message,\n        });\n      }\n    }\n  }\n\n  return results\n}\n\nexport function splitTxAndSigners({ instructions, signers, payer }: {\n  instructions: TransactionInstruction[],\n  signers: (Signer | Keypair)[],\n  payer: PublicKey\n}) {\n  const signerKey: { [key: string]: Signer } = {}\n  for (const item of signers) signerKey[item.publicKey.toString()] = item\n\n  const transactions: { transaction: Transaction, signer: (Keypair | Signer)[] }[] = []\n\n  let itemIns: TransactionInstruction[] = []\n\n  for (const item of instructions) {\n    const _itemIns = [...itemIns, item]\n    const _signerStrs = new Set<string>(_itemIns.map(i => i.keys.filter(ii => ii.isSigner).map(ii => ii.pubkey.toString())).flat())\n    const _signer = [..._signerStrs.values()].map(i => new PublicKey(i))\n\n    if (forecastTransactionSize(_itemIns, [payer, ..._signer])) {\n      itemIns.push(item)\n    } else {\n      transactions.push({\n        transaction: new Transaction().add(...itemIns),\n        signer: [..._signerStrs.values()].map(i => signerKey[i]).filter(i => i !== undefined)\n      })\n\n      itemIns = [item]\n    }\n  }\n\n  if (itemIns.length > 0) {\n    const _signerStrs = new Set<string>(itemIns.map(i => i.keys.filter(ii => ii.isSigner).map(ii => ii.pubkey.toString())).flat())\n    transactions.push({\n      transaction: new Transaction().add(...itemIns),\n      signer: [..._signerStrs.values()].map(i => signerKey[i]).filter(i => i !== undefined)\n    })\n  }\n\n  return transactions\n}","/**\n * https://youmightnotneed.com/lodash/\n */\n\nexport function chunkArray<T>(arr: T[], chunkSize = 1, cache: T[][] = []): T[][] {\n  const tmp = [...arr];\n  if (chunkSize <= 0) return cache;\n  while (tmp.length) cache.push(tmp.splice(0, chunkSize));\n  return cache;\n}\n\nexport function intersection<T>(arr: T[], ...args: T[][]) {\n  return arr.filter((item) => args.every((arr) => arr.includes(item)));\n}\n\nexport function xor<T>(arr: T[], ...args: T[][]) {\n  return arr.filter((item) => args.every((arr) => !arr.includes(item)));\n}\n\nexport function uniq<T>(arr: T[]) {\n  return [...new Set(arr)];\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { version } from \"../version\";\n\n// https://github.com/DABH/colors.js\nimport \"@colors/colors\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [name: string]: number } = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };\nconst _moduleLogLevel: { [name: string]: number } = {};\n\nlet _globalLogger: Logger;\n\nfunction _checkNormalize(): string {\n  try {\n    const missing: Array<string> = [];\n\n    // Make sure all forms of normalization are supported\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n      } catch (error) {\n        missing.push(form);\n      }\n    });\n\n    if (missing.length) {\n      throw new Error(\"missing \" + missing.join(\", \"));\n    }\n\n    if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n  }\n\n  return \"\";\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n  DEBUG = \"DEBUG\",\n  INFO = \"INFO\",\n  WARNING = \"WARNING\",\n  ERROR = \"ERROR\",\n  OFF = \"OFF\",\n}\n\nexport enum ErrorCode {\n  ///////////////////\n  // Generic Errors\n\n  // Unknown Error\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n  // Not Implemented\n  NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n  // Unsupported Operation\n  //   - operation\n  UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n  // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n  //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n  NETWORK_ERROR = \"NETWORK_ERROR\",\n\n  // Some sort of bad response from the server\n  RPC_ERROR = \"RPC_ERROR\",\n\n  // Timeout\n  TIMEOUT = \"TIMEOUT\",\n\n  ///////////////////\n  // Operational  Errors\n\n  // Buffer Overrun\n  BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n  // Numeric Fault\n  //   - operation: the operation being executed\n  //   - fault: the reason this faulted\n  NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n  ///////////////////\n  // Argument Errors\n\n  // Missing new operator to an object\n  //  - name: The name of the class\n  MISSING_NEW = \"MISSING_NEW\",\n\n  // Invalid argument (e.g. value is incompatible with type) to a function:\n  //   - argument: The argument name that was invalid\n  //   - value: The value of the argument\n  INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n  // Missing argument to a function:\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n  // Too many arguments\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n  ///////////////////\n  // Blockchain Errors\n\n  // Insufficien funds (< value + gasLimit * gasPrice)\n  //   - transaction: the transaction attempted\n  INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n}\n\nconst HEX = \"0123456789abcdef\";\n\nfunction perfectDisplay(value: any, deeping = false) {\n  let _value = value;\n\n  try {\n    if (value instanceof Uint8Array) {\n      let hex = \"\";\n      for (let i = 0; i < value.length; i++) {\n        hex += HEX[value[i] >> 4];\n        hex += HEX[value[i] & 0x0f];\n      }\n      _value = `Uint8Array(0x${hex})`;\n    } else if (value instanceof PublicKey) {\n      _value = `PublicKey(${value.toBase58()})`;\n    } else if (value instanceof Object && !deeping) {\n      const obj = {};\n      Object.entries(value).forEach(([k, v]) => {\n        obj[k] = perfectDisplay(v, true);\n      });\n      _value = JSON.stringify(obj);\n    } else if (!deeping) {\n      _value = JSON.stringify(value);\n    }\n  } catch (error) {\n    _value = JSON.stringify(value.toString());\n  }\n\n  return _value;\n}\n\nexport class Logger {\n  readonly version: string = version;\n  readonly moduleName: string;\n\n  static errors = ErrorCode;\n\n  static levels = LogLevel;\n\n  constructor(moduleName: string) {\n    this.moduleName = moduleName;\n  }\n\n  _log(logLevel: LogLevel, args: Array<any>): void {\n    const level = logLevel.toLowerCase();\n    if (LogLevels[level] == null) {\n      this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n    }\n    const _logLevel = _moduleLogLevel[this.moduleName] || LogLevels[\"default\"];\n    if (_logLevel > LogLevels[level]) {\n      return;\n    }\n    console.log(...args);\n  }\n\n  debug(...args: Array<any>): void {\n    this._log(Logger.levels.DEBUG, [\"[DEBUG]\".blue, ...args]);\n  }\n\n  info(...args: Array<any>): void {\n    this._log(Logger.levels.INFO, [\"[INFO]\".green, ...args]);\n  }\n\n  warn(...args: Array<any>): void {\n    this._log(Logger.levels.WARNING, [\"[WARN]\".yellow, ...args]);\n  }\n\n  makeError(message: string, code?: ErrorCode, params?: any): Error {\n    // Errors are being censored\n    if (_censorErrors) {\n      return this.makeError(\"censored error\", code, {});\n    }\n\n    if (!code) {\n      code = Logger.errors.UNKNOWN_ERROR;\n    }\n    if (!params) {\n      params = {};\n    }\n\n    const messageDetails: Array<string> = [];\n    Object.entries(params).forEach(([key, value]) => {\n      messageDetails.push(`${key}=${perfectDisplay(value)})`);\n    });\n    messageDetails.push(`code=${code}`);\n    messageDetails.push(`module=${this.moduleName}`);\n    messageDetails.push(`version=${this.version}`);\n\n    const reason = message;\n    if (messageDetails.length) {\n      message += \" (\" + messageDetails.join(\", \") + \")\";\n    }\n\n    // @TODO: Any??\n    const error: any = new Error(message);\n    error.reason = reason;\n    error.code = code;\n\n    Object.entries(params).forEach(([key, value]) => {\n      error[key] = value;\n    });\n\n    return error;\n  }\n\n  throwError(message: string, code?: ErrorCode, params?: any): never {\n    throw this.makeError(message, code, params);\n  }\n\n  throwArgumentError(message: string, name: string, value: any): never {\n    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n      argument: name,\n      value,\n    });\n  }\n\n  assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n    if (condition) {\n      return;\n    }\n    this.throwError(message, code, params);\n  }\n\n  assertArgument(condition: any, message: string, name: string, value: any): void {\n    if (condition) {\n      return;\n    }\n    this.throwArgumentError(message, name, value);\n  }\n\n  checkNormalize(message?: string): void {\n    if (message == null) {\n      message = \"platform missing String.prototype.normalize\";\n    }\n    if (_normalizeError) {\n      this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"String.prototype.normalize\",\n        form: _normalizeError,\n      });\n    }\n  }\n\n  checkSafeUint53(value: number, message?: string): void {\n    if (typeof value !== \"number\") {\n      return;\n    }\n\n    if (message == null) {\n      message = \"value not safe\";\n    }\n\n    if (value < 0 || value >= 0x1fffffffffffff) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"out-of-safe-range\",\n        value,\n      });\n    }\n\n    if (value % 1) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"non-integer\",\n        value,\n      });\n    }\n  }\n\n  checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message) {\n      message = \": \" + message;\n    } else {\n      message = \"\";\n    }\n\n    if (count < expectedCount) {\n      this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n        count,\n        expectedCount,\n      });\n    }\n\n    if (count > expectedCount) {\n      this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n        count,\n        expectedCount,\n      });\n    }\n  }\n\n  checkNew(target: any, kind: any): void {\n    if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n\n  checkAbstract(target: any, kind: any): void {\n    if (target === kind) {\n      this.throwError(\n        \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n        Logger.errors.UNSUPPORTED_OPERATION,\n        { name: target.name, operation: \"new\" },\n      );\n    } else if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n\n  static globalLogger(): Logger {\n    if (!_globalLogger) {\n      _globalLogger = new Logger(version);\n    }\n    return _globalLogger;\n  }\n\n  static setCensorship(censorship: boolean, permanent?: boolean): void {\n    if (!censorship && permanent) {\n      this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\",\n      });\n    }\n\n    if (_permanentCensorErrors) {\n      if (!censorship) {\n        return;\n      }\n      this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\",\n      });\n    }\n\n    _censorErrors = !!censorship;\n    _permanentCensorErrors = !!permanent;\n  }\n\n  static setLogLevel(moduleName: string, logLevel: \"DEBUG\" | \"INFO\" | \"WARNING\" | \"ERROR\" | \"OFF\"): void {\n    const level = LogLevels[logLevel.toLowerCase()];\n    if (level == null) {\n      Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n      return;\n    }\n    _moduleLogLevel[moduleName] = level;\n  }\n\n  static from(version: string): Logger {\n    return new Logger(version);\n  }\n}\n","export const version = \"1.1.0-beta.6\";\n"],"mappings":"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","names":["PublicKey","Transaction","chunkArray","arr","chunkSize","cache","tmp","PublicKey","version","_permanentCensorErrors","_censorErrors","LogLevels","_moduleLogLevel","_globalLogger","_checkNormalize","missing","form","error","_normalizeError","LogLevel","ErrorCode","HEX","perfectDisplay","value","deeping","_value","hex","i","PublicKey","obj","k","v","_Logger","moduleName","version","logLevel","args","level","message","code","params","messageDetails","key","reason","name","condition","count","expectedCount","target","kind","censorship","permanent","Logger","logger","Logger","getMultipleAccountsInfo","connection","publicKeys","config","__async","batchRequest","commitment","__spreadValues","chunkedKeys","chunkArray","results","batch","keys","key","unsafeRes","accountInfo","data","executable","lamports","owner","rentEpoch","PublicKey","error","getMultipleAccountsInfoWithCustomFlags","publicKeysWithCustomFlag","multipleAccountsInfo","idx","__spreadProps","forecastTransactionSize","instructions","signers","transaction","Transaction","simulateMultipleInstruction","keyword","feePayer","transactions","instruction","simulateTransaction","i","logs","result","filteredLog","log","parseSimulateLogToJson","parseSimulateValue","getLatestBlockhash","encodedTransactions","signData","encodedTransaction","reqData","itemReqIndex","ii","splitTxAndSigners","payer","signerKey","item","itemIns","_itemIns","_signerStrs","_signer"]}