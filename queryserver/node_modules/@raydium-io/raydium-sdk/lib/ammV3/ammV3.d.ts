import { PublicKey, Signer, Keypair, Transaction, TransactionInstruction, Connection } from '@solana/web3.js';
import BN__default from 'bn.js';
import Decimal from 'decimal.js';
import { Base, TokenAccount } from '../base/base.js';
import { CurrencyAmount, TokenAmount } from '../entity/amount.js';
import { Token, Currency } from '../entity/currency.js';
import { Percent } from '../entity/percent.js';
import { Price } from '../entity/price.js';
import { TickArray } from './utils/tick.js';
import '../entity/bignumber.js';
import '../spl/layout.js';
import '../marshmallow/index.js';
import '../marshmallow/buffer-layout.js';
import '../entity/constant.js';
import '../entity/fraction.js';
import '../common/pubkey.js';
import '@solana/spl-token';

interface ApiAmmV3Point {
    price: string;
    liquidity: string;
}
interface ApiAmmV3ConfigInfo {
    id: string;
    index: number;
    protocolFeeRate: number;
    tradeFeeRate: number;
    tickSpacing: number;
    fundFeeRate: number;
    fundOwner: string;
    description: string;
}
interface ApiAmmV3ConfigInfos {
    [configId: string]: ApiAmmV3ConfigInfo;
}
interface AmmV3ConfigInfo {
    id: PublicKey;
    index: number;
    protocolFeeRate: number;
    tradeFeeRate: number;
    tickSpacing: number;
    fundFeeRate: number;
    fundOwner: string;
    description: string;
}
interface ApiAmmV3PoolInfo {
    id: string;
    mintA: string;
    mintB: string;
    mintDecimalsA: number;
    mintDecimalsB: number;
    ammConfig: ApiAmmV3ConfigInfo;
    day: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    week: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    month: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    tvl: number;
}
interface AmmV3PoolRewardLayoutInfo {
    rewardState: number;
    openTime: BN__default;
    endTime: BN__default;
    lastUpdateTime: BN__default;
    emissionsPerSecondX64: BN__default;
    rewardTotalEmissioned: BN__default;
    rewardClaimed: BN__default;
    tokenMint: PublicKey;
    tokenVault: PublicKey;
    creator: PublicKey;
    rewardGrowthGlobalX64: BN__default;
}
interface AmmV3PoolRewardInfo {
    rewardState: number;
    openTime: BN__default;
    endTime: BN__default;
    lastUpdateTime: BN__default;
    emissionsPerSecondX64: BN__default;
    rewardTotalEmissioned: BN__default;
    rewardClaimed: BN__default;
    tokenMint: PublicKey;
    tokenVault: PublicKey;
    creator: PublicKey;
    rewardGrowthGlobalX64: BN__default;
    perSecond: Decimal;
    remainingRewards: undefined | BN__default;
}
interface AmmV3PoolInfo {
    id: PublicKey;
    mintA: {
        mint: PublicKey;
        vault: PublicKey;
        decimals: number;
    };
    mintB: {
        mint: PublicKey;
        vault: PublicKey;
        decimals: number;
    };
    ammConfig: AmmV3ConfigInfo;
    observationId: PublicKey;
    creator: PublicKey;
    programId: PublicKey;
    version: 6;
    tickSpacing: number;
    liquidity: BN__default;
    sqrtPriceX64: BN__default;
    currentPrice: Decimal;
    tickCurrent: number;
    observationIndex: number;
    observationUpdateDuration: number;
    feeGrowthGlobalX64A: BN__default;
    feeGrowthGlobalX64B: BN__default;
    protocolFeesTokenA: BN__default;
    protocolFeesTokenB: BN__default;
    swapInAmountTokenA: BN__default;
    swapOutAmountTokenB: BN__default;
    swapInAmountTokenB: BN__default;
    swapOutAmountTokenA: BN__default;
    tickArrayBitmap: BN__default[];
    rewardInfos: AmmV3PoolRewardInfo[];
    day: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    week: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    month: {
        volume: number;
        volumeFee: number;
        feeA: number;
        feeB: number;
        feeApr: number;
        rewardApr: {
            A: number;
            B: number;
            C: number;
        };
        apr: number;
        priceMin: number;
        priceMax: number;
    };
    tvl: number;
}
interface AmmV3PoolPersonalPosition {
    poolId: PublicKey;
    nftMint: PublicKey;
    priceLower: Decimal;
    priceUpper: Decimal;
    amountA: BN__default;
    amountB: BN__default;
    tickLower: number;
    tickUpper: number;
    liquidity: BN__default;
    feeGrowthInsideLastX64A: BN__default;
    feeGrowthInsideLastX64B: BN__default;
    tokenFeesOwedA: BN__default;
    tokenFeesOwedB: BN__default;
    rewardInfos: {
        growthInsideLastX64: BN__default;
        rewardAmountOwed: BN__default;
        pendingReward: BN__default;
    }[];
    leverage: number;
    tokenFeeAmountA: BN__default;
    tokenFeeAmountB: BN__default;
}
interface MintInfo {
    mint: PublicKey;
    decimals: number;
}
interface ReturnTypeMakeTransaction {
    signers: (Signer | Keypair)[];
    transaction: Transaction;
    address: {
        [name: string]: PublicKey;
    };
}
interface ReturnTypeMakeCreatePoolTransaction {
    signers: (Signer | Keypair)[];
    transaction: Transaction;
    mockPoolInfo: AmmV3PoolInfo;
}
interface ReturnTypeMakeInstructions {
    signers: (Signer | Keypair)[];
    instructions: TransactionInstruction[];
    address: {
        [name: string]: PublicKey;
    };
}
interface ReturnTypeMakeHarvestTranscation {
    transactions: {
        transaction: Transaction;
        signer: Signer[];
    }[];
    address: {
        [key: string]: PublicKey;
    };
}
interface ReturnTypeGetLiquidityAmountOutFromAmountIn {
    liquidity: BN__default;
    amountSlippageA: BN__default;
    amountSlippageB: BN__default;
    amountA: BN__default;
    amountB: BN__default;
}
interface ReturnTypeGetAmountsFromLiquidity {
    amountSlippageA: BN__default;
    amountSlippageB: BN__default;
}
interface ReturnTypeGetPriceAndTick {
    tick: number;
    price: Decimal;
}
interface ReturnTypeGetTickPrice {
    tick: number;
    price: Decimal;
    tickSqrtPriceX64: BN__default;
}
interface ReturnTypeComputeAmountOutFormat {
    amountOut: CurrencyAmount;
    minAmountOut: CurrencyAmount;
    currentPrice: Price;
    executionPrice: Price;
    priceImpact: Percent;
    fee: CurrencyAmount;
    remainingAccounts: PublicKey[];
}
interface ReturnTypeComputeAmountOut {
    amountOut: BN__default;
    minAmountOut: BN__default;
    currentPrice: Decimal;
    executionPrice: Decimal;
    priceImpact: Percent;
    fee: BN__default;
    remainingAccounts: PublicKey[];
}
interface ReturnTypeFetchMultiplePoolInfos {
    [id: string]: {
        state: AmmV3PoolInfo;
        positionAccount?: AmmV3PoolPersonalPosition[] | undefined;
    };
}
interface ReturnTypeFetchMultiplePoolTickArrays {
    [poolId: string]: {
        [key: string]: TickArray;
    };
}
declare class AmmV3 extends Base {
    static makeCreatePoolTransaction({ connection, programId, owner, mint1, mint2, ammConfig, initialPrice }: {
        connection: Connection;
        programId: PublicKey;
        owner: PublicKey;
        mint1: MintInfo;
        mint2: MintInfo;
        ammConfig: AmmV3ConfigInfo;
        initialPrice: Decimal;
    }): Promise<ReturnTypeMakeCreatePoolTransaction>;
    static makeOpenPositionTransaction({ connection, poolInfo, ownerInfo, tickLower, tickUpper, liquidity, slippage, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        tickLower: number;
        tickUpper: number;
        liquidity: BN__default;
        slippage: number;
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeIncreaseLiquidityTransaction({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, slippage }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        liquidity: BN__default;
        slippage: number;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeDecreaseLiquidityTransaction({ connection, poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB, slippage, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
            closePosition?: boolean;
        };
        liquidity: BN__default;
        amountMinA?: BN__default;
        amountMinB?: BN__default;
        slippage?: number;
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeSwapBaseInTransaction({ connection, poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, priceLimit, remainingAccounts }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        inputMint: PublicKey;
        amountIn: BN__default;
        amountOutMin: BN__default;
        priceLimit?: Decimal;
        remainingAccounts: PublicKey[];
    }): Promise<ReturnTypeMakeTransaction>;
    static makeCLosePositionTransaction({ poolInfo, ownerPosition, ownerInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
        };
    }): ReturnTypeMakeTransaction;
    static makeInitRewardTransaction({ connection, poolInfo, ownerInfo, rewardInfo, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        };
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeInitRewardsTransaction({ connection, poolInfo, ownerInfo, rewardInfos, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfos: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        }[];
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeSetRewardTransaction({ connection, poolInfo, ownerInfo, rewardInfo, associatedOnly, }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        };
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeSetRewardsTransaction({ connection, poolInfo, ownerInfo, rewardInfos, associatedOnly, }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardInfos: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            perSecond: Decimal;
        }[];
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeCollectRewardTransaction({ connection, poolInfo, ownerInfo, rewardMint, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardMint: PublicKey;
        associatedOnly: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeCollectRewardsTransaction({ connection, poolInfo, ownerInfo, rewardMints, associatedOnly }: {
        connection: Connection;
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        rewardMints: PublicKey[];
        associatedOnly: boolean;
    }): Promise<ReturnTypeMakeTransaction>;
    static makeHarvestAllRewardTransaction({ connection, fetchPoolInfos, ownerInfo, associatedOnly }: {
        connection: Connection;
        fetchPoolInfos: ReturnTypeFetchMultiplePoolInfos;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            useSOLBalance?: boolean;
        };
        associatedOnly?: boolean;
    }): Promise<ReturnTypeMakeHarvestTranscation>;
    static makeCreatePoolInstructions({ connection, programId, owner, mintA, mintB, ammConfigId, initialPriceX64 }: {
        connection: Connection;
        programId: PublicKey;
        owner: PublicKey;
        mintA: MintInfo;
        mintB: MintInfo;
        ammConfigId: PublicKey;
        initialPriceX64: BN__default;
    }): Promise<ReturnTypeMakeInstructions>;
    static makeOpenPositionInstructions({ poolInfo, ownerInfo, tickLower, tickUpper, liquidity, amountSlippageA, amountSlippageB }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            feePayer: PublicKey;
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        tickLower: number;
        tickUpper: number;
        liquidity: BN__default;
        amountSlippageA: BN__default;
        amountSlippageB: BN__default;
    }): ReturnTypeMakeInstructions;
    static makeIncreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountSlippageA, amountSlippageB }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        liquidity: BN__default;
        amountSlippageA: BN__default;
        amountSlippageB: BN__default;
    }): ReturnTypeMakeInstructions;
    static makeDecreaseLiquidityInstructions({ poolInfo, ownerPosition, ownerInfo, liquidity, amountMinA, amountMinB }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
            rewardAccounts: PublicKey[];
        };
        liquidity: BN__default;
        amountMinA: BN__default;
        amountMinB: BN__default;
    }): ReturnTypeMakeInstructions;
    static makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        ownerInfo: {
            wallet: PublicKey;
        };
    }): ReturnTypeMakeInstructions;
    static makeSwapBaseInInstructions({ poolInfo, ownerInfo, inputMint, amountIn, amountOutMin, sqrtPriceLimitX64, remainingAccounts }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccountA: PublicKey;
            tokenAccountB: PublicKey;
        };
        inputMint: PublicKey;
        amountIn: BN__default;
        amountOutMin: BN__default;
        sqrtPriceLimitX64: BN__default;
        remainingAccounts: PublicKey[];
    }): ReturnTypeMakeInstructions;
    static makeInitRewardInstructions({ poolInfo, ownerInfo, rewardInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            emissionsPerSecondX64: BN__default;
        };
    }): ReturnTypeMakeInstructions;
    static makeSetRewardInstructions({ poolInfo, ownerInfo, rewardInfo }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardInfo: {
            mint: PublicKey;
            openTime: number;
            endTime: number;
            emissionsPerSecondX64: BN__default;
        };
    }): ReturnTypeMakeInstructions;
    static makeCollectRewardInstructions({ poolInfo, ownerInfo, rewardMint }: {
        poolInfo: AmmV3PoolInfo;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccount: PublicKey;
        };
        rewardMint: PublicKey;
    }): ReturnTypeMakeInstructions;
    static getLiquidityAmountOutFromAmountIn({ poolInfo, inputA, tickLower, tickUpper, amount, slippage, add }: {
        poolInfo: AmmV3PoolInfo;
        inputA: boolean;
        tickLower: number;
        tickUpper: number;
        amount: BN__default;
        slippage: number;
        add: boolean;
    }): ReturnTypeGetLiquidityAmountOutFromAmountIn;
    static getAmountsFromLiquidity({ poolInfo, ownerPosition, liquidity, slippage, add }: {
        poolInfo: AmmV3PoolInfo;
        ownerPosition: AmmV3PoolPersonalPosition;
        liquidity: BN__default;
        slippage: number;
        add: boolean;
    }): ReturnTypeGetAmountsFromLiquidity;
    static getPriceAndTick({ poolInfo, price, baseIn }: {
        poolInfo: AmmV3PoolInfo;
        price: Decimal;
        baseIn: boolean;
    }): ReturnTypeGetPriceAndTick;
    static getTickPrice({ poolInfo, tick, baseIn }: {
        poolInfo: AmmV3PoolInfo;
        tick: number;
        baseIn: boolean;
    }): ReturnTypeGetTickPrice;
    static computeAmountOutFormat({ poolInfo, tickArrayCache, amountIn, currencyOut, slippage }: {
        poolInfo: AmmV3PoolInfo;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        amountIn: CurrencyAmount | TokenAmount;
        currencyOut: Token | Currency;
        slippage: Percent;
    }): ReturnTypeComputeAmountOutFormat;
    static computeAmountOut({ poolInfo, tickArrayCache, baseMint, amountIn, slippage, priceLimit }: {
        poolInfo: AmmV3PoolInfo;
        tickArrayCache: {
            [key: string]: TickArray;
        };
        baseMint: PublicKey;
        amountIn: BN__default;
        slippage: number;
        priceLimit?: Decimal;
    }): ReturnTypeComputeAmountOut;
    static estimateAprsForPriceRangeMultiplier({ poolInfo, aprType, positionTickLowerIndex, positionTickUpperIndex }: {
        poolInfo: AmmV3PoolInfo;
        aprType: 'day' | 'week' | 'month';
        positionTickLowerIndex: number;
        positionTickUpperIndex: number;
    }): {
        feeApr: number;
        rewardsApr: number[];
        apr: number;
    };
    static estimateAprsForPriceRangeDelta({ poolInfo, aprType, mintPrice, rewardMintDecimals, liquidity, positionTickLowerIndex, positionTickUpperIndex, chainTime }: {
        poolInfo: AmmV3PoolInfo;
        aprType: 'day' | 'week' | 'month';
        mintPrice: {
            [mint: string]: Price;
        };
        rewardMintDecimals: {
            [mint: string]: number;
        };
        liquidity: BN__default;
        positionTickLowerIndex: number;
        positionTickUpperIndex: number;
        chainTime: number;
    }): {
        feeApr: number;
        rewardsApr: number[];
        apr: number;
    };
    static fetchMultiplePoolInfos({ connection, poolKeys, ownerInfo, chainTime, batchRequest }: {
        connection: Connection;
        poolKeys: ApiAmmV3PoolInfo[];
        ownerInfo?: {
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
        };
        chainTime: number;
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultiplePoolInfos>;
    static fetchMultiplePoolTickArrays({ connection, poolKeys, batchRequest }: {
        connection: Connection;
        poolKeys: AmmV3PoolInfo[];
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultiplePoolTickArrays>;
    static getWhiteListMint({ connection, programId }: {
        connection: Connection;
        programId: PublicKey;
    }): Promise<PublicKey[]>;
}

export { AmmV3, AmmV3ConfigInfo, AmmV3PoolInfo, AmmV3PoolPersonalPosition, AmmV3PoolRewardInfo, AmmV3PoolRewardLayoutInfo, ApiAmmV3ConfigInfo, ApiAmmV3ConfigInfos, ApiAmmV3Point, ApiAmmV3PoolInfo, MintInfo, ReturnTypeComputeAmountOut, ReturnTypeComputeAmountOutFormat, ReturnTypeFetchMultiplePoolInfos, ReturnTypeFetchMultiplePoolTickArrays, ReturnTypeGetAmountsFromLiquidity, ReturnTypeGetLiquidityAmountOutFromAmountIn, ReturnTypeGetPriceAndTick, ReturnTypeGetTickPrice, ReturnTypeMakeCreatePoolTransaction, ReturnTypeMakeHarvestTranscation, ReturnTypeMakeInstructions, ReturnTypeMakeTransaction };
