import { PublicKey, Keypair, Signer, TransactionInstruction, Transaction, Connection } from '@solana/web3.js';
import BN__default from 'bn.js';
import { AmmV3PoolInfo, ReturnTypeFetchMultiplePoolTickArrays } from '../ammV3/ammV3.js';
import { Base, TokenAccount } from '../base/base.js';
import { CurrencyAmount, TokenAmount } from '../entity/amount.js';
import { Token, Currency } from '../entity/currency.js';
import { Percent } from '../entity/percent.js';
import { Price } from '../entity/price.js';
import { b as LiquidityPoolJsonInfo, c as LiquidityPoolsJsonFile } from '../type-b54589b5.js';
import 'decimal.js';
import '../ammV3/utils/tick.js';
import '../entity/bignumber.js';
import '../spl/layout.js';
import '../marshmallow/index.js';
import '../marshmallow/buffer-layout.js';
import '../entity/constant.js';
import '../entity/fraction.js';
import '../common/pubkey.js';
import '@solana/spl-token';
import '../common/json-file.js';

type PoolType = AmmV3PoolInfo | LiquidityPoolJsonInfo;
type RoutePathType = {
    [routeMint: string]: {
        in: PoolType[];
        out: PoolType[];
        mDecimals: number;
    };
};
interface poolAccountInfoV4 {
    ammId: string;
    status: BN__default;
    baseDecimals: number;
    quoteDecimals: number;
    lpDecimals: number;
    baseReserve: BN__default;
    quoteReserve: BN__default;
    lpSupply: BN__default;
    startTime: BN__default;
}
interface ComputeAmountOutAmmLayout {
    amountIn: CurrencyAmount | TokenAmount;
    amountOut: CurrencyAmount | TokenAmount;
    minAmountOut: CurrencyAmount | TokenAmount;
    currentPrice: Price | undefined;
    executionPrice: Price | null;
    priceImpact: Percent;
    fee: CurrencyAmount[];
    routeType: 'amm';
    poolKey: PoolType[];
    remainingAccounts: PublicKey[][];
    middleMint: PublicKey | undefined;
    poolReady: boolean;
    poolType: string | undefined;
}
interface ComputeAmountOutRouteLayout {
    amountIn: CurrencyAmount | TokenAmount;
    amountOut: CurrencyAmount | TokenAmount;
    minAmountOut: CurrencyAmount | TokenAmount;
    currentPrice: Price | undefined;
    executionPrice: Price | null;
    priceImpact: Percent;
    fee: CurrencyAmount[];
    routeType: 'route';
    poolKey: PoolType[];
    remainingAccounts: PublicKey[][];
    middleMint: PublicKey | undefined;
    poolReady: boolean;
    poolType: (string | undefined)[];
}
type ComputeAmountOutLayout = ComputeAmountOutAmmLayout | ComputeAmountOutRouteLayout;
type makeSwapInstructionParam = {
    ownerInfo: {
        wallet: PublicKey;
        sourceToken: PublicKey;
        routeToken?: PublicKey;
        destinationToken: PublicKey;
        userPdaAccount?: PublicKey;
    };
    inputMint: PublicKey;
    routeProgram: PublicKey;
    swapInfo: ComputeAmountOutLayout;
};
interface ReturnTypeGetAllRoute {
    directPath: PoolType[];
    addLiquidityPools: LiquidityPoolJsonInfo[];
    routePathDict: RoutePathType;
    needSimulate: LiquidityPoolJsonInfo[];
    needTickArray: AmmV3PoolInfo[];
}
interface ReturnTypeFetchMultipleInfo {
    [ammId: string]: poolAccountInfoV4;
}
type ReturnTypeGetAddLiquidityDefaultPool = LiquidityPoolJsonInfo | undefined;
type ReturnTypeGetAllRouteComputeAmountOut = ComputeAmountOutLayout[];
interface ReturnTypeMakeSwapInstruction {
    signers: (Keypair | Signer)[];
    instructions: TransactionInstruction[];
    address: {
        [key: string]: PublicKey;
    };
}
interface ReturnTypeMakeSwapTranscation {
    transactions: {
        transaction: Transaction;
        signer: (Keypair | Signer)[];
    }[];
    address: {
        [key: string]: PublicKey;
    };
}
declare class TradeV2 extends Base {
    static getAllRoute({ inputMint, outputMint, apiPoolList, ammV3List }: {
        inputMint: PublicKey;
        outputMint: PublicKey;
        apiPoolList?: LiquidityPoolsJsonFile;
        ammV3List?: AmmV3PoolInfo[];
    }): ReturnTypeGetAllRoute;
    static fetchMultipleInfo({ connection, pools, batchRequest }: {
        connection: Connection;
        pools: LiquidityPoolJsonInfo[];
        batchRequest?: boolean;
    }): Promise<ReturnTypeFetchMultipleInfo>;
    static getAddLiquidityDefaultPool({ addLiquidityPools, poolInfosCache }: {
        addLiquidityPools: LiquidityPoolJsonInfo[];
        poolInfosCache: {
            [ammId: string]: poolAccountInfoV4;
        };
    }): ReturnTypeGetAddLiquidityDefaultPool;
    private static ComparePoolSize;
    static getAllRouteComputeAmountOut({ inputTokenAmount, outputToken, directPath, routePathDict, simulateCache, tickCache, slippage, chainTime }: {
        directPath: PoolType[];
        routePathDict: RoutePathType;
        simulateCache: ReturnTypeFetchMultipleInfo;
        tickCache: ReturnTypeFetchMultiplePoolTickArrays;
        inputTokenAmount: CurrencyAmount | TokenAmount;
        outputToken: Token | Currency;
        slippage: Percent;
        chainTime: number;
    }): ReturnTypeGetAllRouteComputeAmountOut;
    private static computeAmountOut;
    static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }: makeSwapInstructionParam): ReturnTypeMakeSwapInstruction;
    static makeSwapTranscation({ connection, swapInfo, ownerInfo, checkTransaction }: {
        connection: Connection;
        swapInfo: ComputeAmountOutLayout;
        ownerInfo: {
            wallet: PublicKey;
            tokenAccounts: TokenAccount[];
            associatedOnly: boolean;
        };
        checkTransaction: boolean;
    }): Promise<ReturnTypeMakeSwapTranscation>;
}

export { ComputeAmountOutAmmLayout, ComputeAmountOutRouteLayout, PoolType, ReturnTypeFetchMultipleInfo, ReturnTypeGetAddLiquidityDefaultPool, ReturnTypeGetAllRoute, ReturnTypeGetAllRouteComputeAmountOut, ReturnTypeMakeSwapInstruction, ReturnTypeMakeSwapTranscation, TradeV2 };
